#
# Python Module with Class
# for Vectorized Backtesting
# of Linear Regression-Based Strategies (India Edition)
#
# Modified from: Python for Algorithmic Trading (Dr. Yves J. Hilpisch)
# Updated to support Indian stocks via yfinance
#

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

class LRVectorBacktester:
    '''Class for vectorized backtesting of linear regression-based trading strategies.
    
    Attributes
    ==========
    symbol : str
        Yahoo Finance ticker (e.g., 'MAHABANK.NS', 'RELIANCE.NS')
    start : str
        Start date for data (e.g., '2015-01-01')
    end : str
        End date for data
    amount : int or float
        Initial investment amount (e.g., 10000)
    tc : float
        Proportional transaction costs per trade (e.g., 0.001 = 0.1%)
    
    Methods
    =======
    get_data()          : Fetches and prepares price & log returns
    select_data()       : Selects data between two dates
    prepare_lags()      : Creates lagged return features
    fit_model()         : Fits linear regression on sign of returns
    run_strategy()      : Runs backtest (in-sample train + out-of-sample test)
    plot_results()      : Plots cumulative performance
    '''
    
    def __init__(self, symbol, start, end, amount, tc):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.amount = amount
        self.tc = tc
        self.results = None
        self.get_data()
    
    def get_data(self):
        '''Fetches data from Yahoo Finance and prepares log returns.'''
        print(f"ğŸ“¥ Downloading data for {self.symbol} from {self.start} to {self.end}...")
        data = yf.download(self.symbol, start=self.start, end=self.end)
        if data.empty:
            raise ValueError(f"No data found for symbol: {self.symbol}")
        
        data = data[['Close']].copy()
        data.rename(columns={'Close': 'price'}, inplace=True)
        data['returns'] = np.log(data['price'] / data['price'].shift(1))
        self.data = data.dropna()
        print(f"âœ… Data loaded: {len(self.data)} trading days.")
    
    def select_data(self, start, end):
        '''Selects a subset of the data between start and end dates.'''
        data = self.data[(self.data.index >= start) & (self.data.index <= end)].copy()
        return data
    
    def prepare_lags(self, start, end):
        '''Prepares lagged return features for regression.'''
        data = self.select_data(start, end)
        self.cols = []
        for lag in range(1, self.lags + 1):
            col = f'lag_{lag}'
            data[col] = data['returns'].shift(lag)
            self.cols.append(col)
        data.dropna(inplace=True)
        self.lagged_data = data
    
    def fit_model(self, start, end):
        '''Fits linear regression to predict sign of future returns.'''
        self.prepare_lags(start, end)
        # Target: +1 if return > 0, -1 if return < 0
        target = np.sign(self.lagged_data['returns'])
        # Solve: X @ weights â‰ˆ target
        reg = np.linalg.lstsq(self.lagged_data[self.cols], target, rcond=None)[0]
        self.reg = reg
    
    def run_strategy(self, start_in, end_in, start_out, end_out, lags=3):
        '''Runs the full backtest strategy.'''
        self.lags = lags
        self.fit_model(start_in, end_in)
        
        # Prepare out-of-sample data
        self.results = self.select_data(start_out, end_out).iloc[lags:].copy()
        self.prepare_lags(start_out, end_out)
        
        # Generate predictions (+1 or -1)
        prediction = np.sign(np.dot(self.lagged_data[self.cols], self.reg))
        self.results['prediction'] = prediction
        
        # Strategy returns = prediction * actual returns
        self.results['strategy'] = self.results['prediction'] * self.results['returns']
        
        # Apply transaction costs only on trade changes
        trades = self.results['prediction'].diff().fillna(0) != 0
        self.results.loc[trades, 'strategy'] -= self.tc
        
        # Calculate cumulative performance
        self.results['creturns'] = self.amount * np.exp(self.results['returns'].cumsum())
        self.results['cstrategy'] = self.amount * np.exp(self.results['strategy'].cumsum())
        
        # Final performance metrics
        aperf = self.results['cstrategy'].iloc[-1]
        operf = aperf - self.results['creturns'].iloc[-1]
        
        return round(aperf, 2), round(operf, 2)
    
    def plot_results(self):
        '''Plots cumulative performance of strategy vs buy-and-hold.'''
        if self.results is None:
            print("âŒ No results to plot. Run run_strategy() first.")
            return
        
        title = f'{self.symbol} | Transaction Cost = {self.tc:.4f}'
        self.results[['creturns', 'cstrategy']].plot(
            title=title, figsize=(12, 7), linewidth=2
        )
        plt.ylabel('Portfolio Value (â‚¹)')
        plt.xlabel('Date')
        plt.grid(True)
        plt.legend(['Buy & Hold', 'LR Strategy'])
        plt.tight_layout()
        plt.show()


# ======================
# ğŸ”§ HOW TO USE IT
# ======================

if __name__ == '__main__':
    # Example 1: Bank of Maharashtra (MAHABANK.NS)
    print("\n" + "="*60)
    print("ğŸš€ BACKTESTING BANK OF MAHARASHTRA (MAHABANK.NS)")
    print("="*60)
    
    # Create backtester object
    lrbt = LRVectorBacktester(
        symbol='MAHABANK.NS',
        start='2015-01-01',
        end='2025-10-20',
        amount=10000,      # â‚¹10,000 initial investment
        tc=0.001           # 0.1% transaction cost per trade
    )
    
    # Run strategy: Train on 2015â€“2020, Test on 2021â€“2025
    final_value, outperformance = lrbt.run_strategy(
        start_in='2015-01-01',
        end_in='2020-12-31',
        start_out='2021-01-01',
        end_out='2025-10-20',
        lags=3
    )
    
    print(f"\nğŸ“ˆ Final Portfolio Value: â‚¹{final_value:,.2f}")
    print(f"ğŸ“Š Outperformance vs Buy & Hold: â‚¹{outperformance:,.2f}")
    
    # Plot results
    lrbt.plot_results()
    
    # -------------------------------------------------
    # Example 2: Nifty 50 ETF (if you want index exposure)
    # -------------------------------------------------
    print("\n" + "="*60)
    print("ğŸ“ˆ BACKTESTING NIFTY BEES (NIFTYBEES.NS)")
    print("="*60)
    
    try:
        lrbt2 = LRVectorBacktester(
            symbol='NIFTYBEES.NS',
            start='2015-01-01',
            end='2025-10-20',
            amount=10000,
            tc=0.0005  # Lower cost for ETFs
        )
        fv2, op2 = lrbt2.run_strategy(
            '2015-01-01', '2020-12-31',
            '2021-01-01', '2025-10-20',
            lags=5
        )
        print(f"\nğŸ“ˆ Final Value: â‚¹{fv2:,.2f} | Outperformance: â‚¹{op2:,.2f}")
        lrbt2.plot_results()
    except Exception as e:
        print(f"âš ï¸ Could not fetch NIFTYBEES data: {e}")